<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<!--
generated by Pygments <https://pygments.org/>
Copyright 2006-2021 by the Pygments team.
Licensed under the BSD license, see LICENSE for details.
-->
<html>
<head>
  <title></title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <style type="text/css">
/*
generated by Pygments <https://pygments.org/>
Copyright 2006-2021 by the Pygments team.
Licensed under the BSD license, see LICENSE for details.
*/
pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
body .hll { background-color: #ffffcc }
body { background: #ffffff; }
body .c { color: #008000 } /* Comment */
body .err { border: 1px solid #FF0000 } /* Error */
body .k { color: #0000ff } /* Keyword */
body .ch { color: #008000 } /* Comment.Hashbang */
body .cm { color: #008000 } /* Comment.Multiline */
body .cp { color: #0000ff } /* Comment.Preproc */
body .cpf { color: #008000 } /* Comment.PreprocFile */
body .c1 { color: #008000 } /* Comment.Single */
body .cs { color: #008000 } /* Comment.Special */
body .ge { font-style: italic } /* Generic.Emph */
body .gh { font-weight: bold } /* Generic.Heading */
body .gp { font-weight: bold } /* Generic.Prompt */
body .gs { font-weight: bold } /* Generic.Strong */
body .gu { font-weight: bold } /* Generic.Subheading */
body .kc { color: #0000ff } /* Keyword.Constant */
body .kd { color: #0000ff } /* Keyword.Declaration */
body .kn { color: #0000ff } /* Keyword.Namespace */
body .kp { color: #0000ff } /* Keyword.Pseudo */
body .kr { color: #0000ff } /* Keyword.Reserved */
body .kt { color: #2b91af } /* Keyword.Type */
body .s { color: #a31515 } /* Literal.String */
body .nc { color: #2b91af } /* Name.Class */
body .ow { color: #0000ff } /* Operator.Word */
body .sa { color: #a31515 } /* Literal.String.Affix */
body .sb { color: #a31515 } /* Literal.String.Backtick */
body .sc { color: #a31515 } /* Literal.String.Char */
body .dl { color: #a31515 } /* Literal.String.Delimiter */
body .sd { color: #a31515 } /* Literal.String.Doc */
body .s2 { color: #a31515 } /* Literal.String.Double */
body .se { color: #a31515 } /* Literal.String.Escape */
body .sh { color: #a31515 } /* Literal.String.Heredoc */
body .si { color: #a31515 } /* Literal.String.Interpol */
body .sx { color: #a31515 } /* Literal.String.Other */
body .sr { color: #a31515 } /* Literal.String.Regex */
body .s1 { color: #a31515 } /* Literal.String.Single */
body .ss { color: #a31515 } /* Literal.String.Symbol */

  </style>
</head>
<body>
<h2></h2>

<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%;"><span></span><span style="color: #0000ff">#!/usr/bin/env lua</span>
<span style="color: #008000">-- vim: filetype=lua ts=2 sw=2 sts=2 et :</span>
<span style="color: #0000ff">local</span> b4={}; <span style="color: #0000ff">for</span> k,_ <span style="color: #0000ff">in</span> pairs(_ENV) <span style="color: #0000ff">do</span> b4[k]=k <span style="color: #0000ff">end</span>
<span style="color: #0000ff">local</span> about=<span style="color: #a31515">[[</span>
<span style="color: #a31515"> ,-_|\   Contrast set learning</span>
<span style="color: #a31515">/     \  (c) Tim Menzies, 2021, unlicense.org</span>
<span style="color: #a31515">\_,-._*  Cluster, then report just the </span>
<span style="color: #a31515">     v   deltas between nearby clusters.]]</span>
<span style="color: #008000">-------------------------------------------------</span>
<span style="color: #0000ff">local</span> argparse = require(<span style="color: #a31515">&quot;argparse&quot;</span>)

<span style="color: #0000ff">local</span> <span style="color: #0000ff">function</span> config() <span style="color: #0000ff">return</span>  {
  bins=    {.5     ,<span style="color: #a31515">&#39;bins are of size n**BINS&#39;</span>},
  cols=    {<span style="color: #a31515">&#39;x&#39;</span>    ,<span style="color: #a31515">&#39;columns to use for inference&#39;</span>},
  data=    {<span style="color: #a31515">&#39;../data/auto2.csv&#39;</span>, 
                   <span style="color: #a31515">&#39;where to read data&#39;</span>},
  far=     {.9     ,<span style="color: #a31515">&#39;where to look for far things&#39;</span>},
  goaL=    {<span style="color: #a31515">&#39;best&#39;</span> ,<span style="color: #a31515">&#39;learning goals: best|rest|other&#39;</span>},
  iota=    {.3     ,<span style="color: #a31515">&#39;small = sd**iota&#39;</span>},
  k=       {2      ,<span style="color: #a31515">&#39;bayes low class frequency hack&#39;</span>},
  m=       {1      ,<span style="color: #a31515">&#39;bayes low range frequency hack&#39;</span>},
  p=       {2      ,<span style="color: #a31515">&#39;distance calculation exponent&#39;</span>},
  samples= {20     ,<span style="color: #a31515">&#39;#samples to find far things?&#39;</span>},
  seed=    {10013  , <span style="color: #a31515">&#39;seed for random numbers&#39;</span>},
  top=     {10     ,<span style="color: #a31515">&#39;focus on this many&#39;</span>},
  unsafe=  {<span style="color: #0000ff">false</span>  ,<span style="color: #a31515">&#39;run example, no protection&#39;</span>},
  verbose= {<span style="color: #0000ff">false</span>  ,<span style="color: #a31515">&#39;set verbose&#39;</span>},
  xample=  {<span style="color: #a31515">&quot;&quot;</span>     ,<span style="color: #a31515">&quot;&#39;-x ls&#39; lists all, &#39;-x all&#39; runs all&quot;</span>}} <span style="color: #0000ff">end</span>

<span style="color: #0000ff">local</span> <span style="color: #0000ff">function</span> sorted(t,         i,keys)
  i,keys = 0,{}
  <span style="color: #0000ff">for</span> k <span style="color: #0000ff">in</span> pairs(t) <span style="color: #0000ff">do</span> keys[#keys+1] = k <span style="color: #0000ff">end</span>
  table.sort(keys)
  <span style="color: #0000ff">return</span> <span style="color: #0000ff">function</span> ()
    <span style="color: #0000ff">if</span> i &lt; #keys <span style="color: #0000ff">then</span>
      i=i+1; <span style="color: #0000ff">return</span> keys[i], t[keys[i]] <span style="color: #0000ff">end</span> <span style="color: #0000ff">end</span> <span style="color: #0000ff">end</span>

<span style="color: #0000ff">local</span> <span style="color: #0000ff">function</span> cli(what,about,t,       arg)
  arg = argparse(what, about)
  <span style="color: #0000ff">for</span> flag,v <span style="color: #0000ff">in</span> sorted(t) <span style="color: #0000ff">do</span>
    flag = <span style="color: #a31515">&quot;--&quot;</span>..flag
    <span style="color: #0000ff">if</span>   v[1]==<span style="color: #0000ff">false</span>
    <span style="color: #0000ff">then</span> arg:flag(flag, v[2], v[1])
    <span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> type(b4)==number 
    <span style="color: #0000ff">then</span> arg:option(flag, v[2], v[1]):convert{tonumber}
    <span style="color: #0000ff">else</span> arg:option(flag, v[2], v[1]) <span style="color: #0000ff">end</span> <span style="color: #0000ff">end</span> <span style="color: #0000ff">end</span>
  <span style="color: #0000ff">return</span> arg:parse() <span style="color: #0000ff">end</span>

print(cli(<span style="color: #a31515">&quot;./keys&quot;</span>, about, config()).k)
<span style="color: #0000ff">for</span> k,_ <span style="color: #0000ff">in</span> pairs(_ENV) <span style="color: #0000ff">do</span> <span style="color: #0000ff">if</span> <span style="color: #0000ff">not</span> b4[k] <span style="color: #0000ff">then</span> print(<span style="color: #a31515">&quot;?? &quot;</span>..k) <span style="color: #0000ff">end</span> <span style="color: #0000ff">end</span>
</pre></div>
</body>
</html>
